<!DOCTYPE html>
<html lang>
  <head><meta name="generator" content="Hexo 3.9.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="String类">




  <meta name="keywords" content="JavaBasics,">





  <link rel="alternate" href="/default" title="Illusory">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1">



<link rel="canonical" href="http://yaoper.github.io/2019/08/12/String类/">


<meta name="description" content="概览String 被声明为 final，因此它不可被继承。内部使用 char 数组存储数据，该数组被声明为 final， 这意味着 value 数组初始化之后就不能再引用其它数组。 并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。   123public final class String implements java.io.Serializabl">
<meta name="keywords" content="JavaBasics">
<meta property="og:type" content="article">
<meta property="og:title" content="String类">
<meta property="og:url" content="http://yaoper.github.io/2019/08/12/String类/index.html">
<meta property="og:site_name" content="Illusory">
<meta property="og:description" content="概览String 被声明为 final，因此它不可被继承。内部使用 char 数组存储数据，该数组被声明为 final， 这意味着 value 数组初始化之后就不能再引用其它数组。 并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。   123public final class String implements java.io.Serializabl">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-08-12T07:54:52.137Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="String类">
<meta name="twitter:description" content="概览String 被声明为 final，因此它不可被继承。内部使用 char 数组存储数据，该数组被声明为 final， 这意味着 value 数组初始化之后就不能再引用其它数组。 并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。   123public final class String implements java.io.Serializabl">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1">
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> String类 - Illusory </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">Illusory</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          String类
        
      </h1>

      <time class="post-time">
          Aug 12 2019
      </time>
    </header>



    
            <div class="post-content">
            <h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><p>String 被声明为 final，因此它不可被继承。<br>内部使用 char 数组存储数据，该数组被声明为 final， 这意味着 value 数组初始化之后就不能再引用其它数组。 并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure>

<h4 id="不可变的好处"><a href="#不可变的好处" class="headerlink" title="不可变的好处"></a>不可变的好处</h4><ol>
<li><p>可以缓存 hash 值<br>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。 不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p>
</li>
<li><p>String Pool 的需要<br>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。 只有 String 是不可变的，才可能使用 String Pool。</p>
</li>
<li><p>安全性<br>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p>
</li>
<li><p>线程安全<br>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p>
</li>
</ol>
<h4 id="String-StringBuffer-and-StringBuilder"><a href="#String-StringBuffer-and-StringBuilder" class="headerlink" title="String, StringBuffer and StringBuilder"></a>String, StringBuffer and StringBuilder</h4><ol>
<li>可变性</li>
</ol>
<ul>
<li>String 不可变</li>
<li>StringBuffer 和 StringBuilder 可变</li>
</ul>
<ol start="2">
<li>线程安全</li>
</ol>
<ul>
<li>String 不可变，因此是线程安全的</li>
<li>StringBuilder 不是线程安全的</li>
<li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li>
</ul>
<ol start="3">
<li>性能</li>
</ol>
<ul>
<li>Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢</li>
<li>StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用</li>
<li>StringBuilder每次都会对StringBuilder对象本身进行操作，而不是生成新的对象并改变对象引用。 相同情况下使用StirngBuilder相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却冒多线程不安全的风险。</li>
</ul>
<ol start="4">
<li>三者使用总结</li>
</ol>
<ul>
<li>操作少量的数据，使用String</li>
<li>单线程操作字符串缓冲区下操作大量数据，使用StringBuilder</li>
<li>多线程操作字符串缓冲区下操作大量数据，使用StringBuffer</li>
</ul>
<ol start="5">
<li>String和StringBuffer的相互转换<br>（1）String –&gt; StringBuffer<br>方式一：构造方法 StringBuffer sb = new StringBuffer(s);<br>方式二：通过append()方法 StringBuffer sb = new StringBuffer(); sb.append(s);<br>（2）StringBuffer –&gt; String<br>方式一：构造方法 String s=new String(buffer);<br>方式二：通过toString()方法 String s=buffer.toString();  </li>
</ol>
<h4 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h4><p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。<br>不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。<br>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定）， 那么就会返回 String Pool 中字符串的引用； 否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。<br>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串， 而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。 intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。 因此 s3 和 s4 引用的是同一个字符串。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line">String s3 = s1.intern();</span><br><span class="line">String s4 = s1.intern();</span><br><span class="line">System.out.println(s3 == s4);           <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s5 = <span class="string">"bbb"</span>;</span><br><span class="line">String s6 = <span class="string">"bbb"</span>;</span><br><span class="line">System.out.println(s5 == s6);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。 而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p>
<h4 id="new-String-“abc”"><a href="#new-String-“abc”" class="headerlink" title="new String(“abc”)"></a>new String(“abc”)</h4><p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。<br>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量；<br>而使用 new 的方式会在堆中创建一个字符串对象。<br>创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewStringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 javap -verbose 进行反编译，得到以下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">Constant pool:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">   #2 = Class              #18            // java/lang/String</span><br><span class="line">   #3 = String             #19            // abc</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  #18 = Utf8               java/lang/String</span><br><span class="line">  #19 = Utf8               abc</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: new           #2                  // class java/lang/String</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: ldc           #3                  // String abc</span><br><span class="line">         6: invokespecial #4                  // Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">9</span>: astore_1</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>在 Constant Pool 中，#19 存储这字符串字面量 “abc”，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。</p>
<p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>了解：说说String s=new String(“aaa”)和String s=”aaa”的区别？<br>前者会创建一个或者多个对象<br>后者只会创建一个或者零个对象</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/JavaBasics/">JavaBasics</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2019/08/12/运算/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">运算</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2019/08/12/数据类型/">
        <span class="next-text nav-default">数据类型</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2019
    <span class="footer-author">yaoper.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a> and <a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
