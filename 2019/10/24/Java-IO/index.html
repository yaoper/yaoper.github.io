<!DOCTYPE html>
<html lang>
  <head><meta name="generator" content="Hexo 3.9.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="Java IO">




  <meta name="keywords" content="JavaBasics,">





  <link rel="alternate" href="/default" title="Illusory">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1">



<link rel="canonical" href="http://yaoper.github.io/2019/10/24/Java-IO/">


<meta name="description" content="输入输出流在java io的中，我们经常会提到“输入流”、“输出流”等概念。所谓“流”，就是一种抽象的数据的总称，它的本质是能够进行传输。按照“流”的数据流向，可以将其化分为：输入流和输出流。按照“流”中处理数据的单位，可以将其区分为：字节流和字符流。在java中，字节是占1个Byte，即8位；而字符是占2个Byte，即16位。而且，需要的是，java的字节是有符号类型，而字符是无符号类型！ 以字">
<meta name="keywords" content="JavaBasics">
<meta property="og:type" content="article">
<meta property="og:title" content="Java IO">
<meta property="og:url" content="http://yaoper.github.io/2019/10/24/Java-IO/index.html">
<meta property="og:site_name" content="Illusory">
<meta property="og:description" content="输入输出流在java io的中，我们经常会提到“输入流”、“输出流”等概念。所谓“流”，就是一种抽象的数据的总称，它的本质是能够进行传输。按照“流”的数据流向，可以将其化分为：输入流和输出流。按照“流”中处理数据的单位，可以将其区分为：字节流和字符流。在java中，字节是占1个Byte，即8位；而字符是占2个Byte，即16位。而且，需要的是，java的字节是有符号类型，而字符是无符号类型！ 以字">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://uufe-web.oss-cn-beijing.aliyuncs.com/PicLib/uunote/images/%E4%BB%A5%E5%AD%97%E8%8A%82%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84%E8%BE%93%E5%85%A5%E6%B5%81%E7%9A%84%E6%A1%86%E6%9E%B6%E5%9B%BE_1571903604081.jpg">
<meta property="og:image" content="https://uufe-web.oss-cn-beijing.aliyuncs.com/PicLib/uunote/images/%E4%BB%A5%E5%AD%97%E8%8A%82%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84%E8%BE%93%E5%87%BA%E6%B5%81_1571905776236.jpg">
<meta property="og:image" content="https://uufe-web.oss-cn-beijing.aliyuncs.com/PicLib/uunote/images/%E4%BB%A5%E5%AD%97%E7%AC%A6%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84%E8%BE%93%E5%85%A5%E6%B5%81%E6%A1%86%E6%9E%B6%E5%9B%BE_1571908582642.jpg">
<meta property="og:image" content="https://uufe-web.oss-cn-beijing.aliyuncs.com/PicLib/uunote/images/%E5%AD%97%E8%8A%82%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E6%A1%86%E6%9E%B6%E5%9B%BE_1571908820860.jpg">
<meta property="og:image" content="https://uufe-web.oss-cn-beijing.aliyuncs.com/PicLib/uunote/images/%E4%BB%A5%E5%AD%97%E7%AC%A6%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84%E8%BE%93%E5%87%BA%E6%B5%81%E7%9A%84%E6%A1%86%E6%9E%B6%E5%9B%BE_1571908906451.jpg">
<meta property="og:updated_time" content="2019-10-25T08:37:52.157Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java IO">
<meta name="twitter:description" content="输入输出流在java io的中，我们经常会提到“输入流”、“输出流”等概念。所谓“流”，就是一种抽象的数据的总称，它的本质是能够进行传输。按照“流”的数据流向，可以将其化分为：输入流和输出流。按照“流”中处理数据的单位，可以将其区分为：字节流和字符流。在java中，字节是占1个Byte，即8位；而字符是占2个Byte，即16位。而且，需要的是，java的字节是有符号类型，而字符是无符号类型！ 以字">
<meta name="twitter:image" content="https://uufe-web.oss-cn-beijing.aliyuncs.com/PicLib/uunote/images/%E4%BB%A5%E5%AD%97%E8%8A%82%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84%E8%BE%93%E5%85%A5%E6%B5%81%E7%9A%84%E6%A1%86%E6%9E%B6%E5%9B%BE_1571903604081.jpg">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1">
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> Java IO - Illusory </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">Illusory</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Java IO
        
      </h1>

      <time class="post-time">
          Oct 24 2019
      </time>
    </header>



    
            <div class="post-content">
            <h4 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h4><p>在java io的中，我们经常会提到“输入流”、“输出流”等概念。所谓“流”，就是一种抽象的数据的总称，它的本质是能够进行传输。<br>按照“流”的数据流向，可以将其化分为：输入流和输出流。<br>按照“流”中处理数据的单位，可以将其区分为：字节流和字符流。在java中，字节是占1个Byte，即8位；而字符是占2个Byte，即16位。而且，需要的是，java的字节是有符号类型，而字符是无符号类型！</p>
<p><strong>以字节为单位的输入流</strong></p>
<p>以字节为单位的输入流的框架图<br><img src="https://uufe-web.oss-cn-beijing.aliyuncs.com/PicLib/uunote/images/%E4%BB%A5%E5%AD%97%E8%8A%82%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84%E8%BE%93%E5%85%A5%E6%B5%81%E7%9A%84%E6%A1%86%E6%9E%B6%E5%9B%BE_1571903604081.jpg" alt="以字节为单位的输入流的框架图.jpg"></p>
<p>1.InputStream 是以字节为单位的输入流的超类。InputStream提供了read()接口从输入流中读取字节数据。<br>2.ByteArrayInputStream 是字节数组输入流。它包含一个内部缓冲区，该缓冲区包含从流中读取的字节；通俗点说，它的内部缓冲区就是一个字节数组，而ByteArrayInputStream本质就是通过字节数组来实现的。<br>3.PipedInputStream 是管道输入流，它和PipedOutputStream一起使用，能实现多线程间的管道通信。<br>4.FilterInputStream 是过滤输入流。它是DataInputStream和BufferedInputStream的超类。<br>5.DataInputStream 是数据输入流。它是用来装饰其它输入流，它“允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型”。<br>6.BufferedInputStream 是缓冲输入流。它的作用是为另一个输入流添加缓冲功能。<br>7.File 是“文件”和“目录路径名”的抽象表示形式。关于File，注意两点： a), File不仅仅只是表示文件，它也可以表示目录！ b), File虽然在io包重定义，但是它的超类是Object，而不是InputStream。<br>8.FileDescriptor 是“文件描述符”。它可以被用来表示开放文件、开放套接字等。<br>9.FileInputStream 是文件输入流。它通常用于对文件进行读取操作。<br>10.ObjectInputStream 是对象输入流。它和ObjectOutputStream一起，用来提供对“基本数据或对象”的持久存储。</p>
<p><strong>以字节为单位的输出流</strong><br><img src="https://uufe-web.oss-cn-beijing.aliyuncs.com/PicLib/uunote/images/%E4%BB%A5%E5%AD%97%E8%8A%82%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84%E8%BE%93%E5%87%BA%E6%B5%81_1571905776236.jpg" alt="以字节为单位的输出流.jpg"></p>
<p>1.OutputStream 是以字节为单位的输出流的超类。OutputStream提供了write()接口从输出流中读取字节数据。<br>2.ByteArrayOutputStream 是字节数组输出流。写入ByteArrayOutputStream的数据被写入一个 byte 数组。缓冲区会随着数据的不断写入而自动增长。可使用 toByteArray() 和 toString() 获取数据。<br>3.PipedOutputStream 是管道输出流，它和PipedInputStream一起使用，能实现多线程间的管道通信。<br>4.FilterOutputStream 是过滤输出流。它是DataOutputStream，BufferedOutputStream和PrintStream的超类。<br>5.DataOutputStream 是数据输出流。它是用来装饰其它输出流，它“允许应用程序以与机器无关方式向底层写入基本 Java 数据类型”。<br>6.BufferedOutputStream 是缓冲输出流。它的作用是为另一个输出流添加缓冲功能。<br>7.PrintStream 是打印输出流。它是用来装饰其它输出流，能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。<br>8.FileOutputStream 是文件输出流。它通常用于向文件进行写入操作。<br>9.ObjectOutputStream 是对象输出流。它和ObjectInputStream一起，用来提供对“基本数据或对象”的持久存储。</p>
<p><strong>以字符为单位的输入流</strong><br><img src="https://uufe-web.oss-cn-beijing.aliyuncs.com/PicLib/uunote/images/%E4%BB%A5%E5%AD%97%E7%AC%A6%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84%E8%BE%93%E5%85%A5%E6%B5%81%E6%A1%86%E6%9E%B6%E5%9B%BE_1571908582642.jpg" alt="以字符为单位的输入流框架图.jpg"></p>
<p>1.Reader 是以字符为单位的输入流的超类。它提供了read()接口来取字符数据。<br>2.CharArrayReader 是字符数组输入流。它用于读取字符数组，它继承于Reader。操作的数据是以字符为单位！<br>3.PipedReader 是字符类型的管道输入流。它和PipedWriter一起是可以通过管道进行线程间的通讯。在使用管道通信时，必须将PipedWriter和PipedReader配套使用。<br>4.FilterReader 是字符类型的过滤输入流。<br>5.BufferedReader 是字符缓冲输入流。它的作用是为另一个输入流添加缓冲功能。<br>6.InputStreamReader 是字节转字符的输入流。它是字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符。<br>7.FileReader 是字符类型的文件输入流。它通常用于对文件进行读取操作。</p>
<p><strong>字节流与字符流可以互相转化</strong><br><img src="https://uufe-web.oss-cn-beijing.aliyuncs.com/PicLib/uunote/images/%E5%AD%97%E8%8A%82%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E6%A1%86%E6%9E%B6%E5%9B%BE_1571908820860.jpg" alt="字节转换为字符流的框架图.jpg"></p>
<p>1.FileReader继承于InputStreamReader，而InputStreamReader依赖于InputStream。具体表现在InputStreamReader的构造函数是以InputStream为参数。我们传入InputStream，在InputStreamReader内部通过转码，将字节转换成字符。<br>2.FileWriter继承于OutputStreamWriter，而OutputStreamWriter依赖于OutputStream。具体表现在OutputStreamWriter的构造函数是以OutputStream为参数。我们传入OutputStream，在OutputStreamWriter内部通过转码，将字节转换成字符。</p>
<p><strong>以字符为单位的输出流</strong><br><img src="https://uufe-web.oss-cn-beijing.aliyuncs.com/PicLib/uunote/images/%E4%BB%A5%E5%AD%97%E7%AC%A6%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84%E8%BE%93%E5%87%BA%E6%B5%81%E7%9A%84%E6%A1%86%E6%9E%B6%E5%9B%BE_1571908906451.jpg" alt="以字符为单位的输出流的框架图.jpg"></p>
<p>1.Writer 是以字符为单位的输出流的超类。它提供了write()接口往其中写入数据。<br>2.CharArrayWriter 是字符数组输出流。它用于读取字符数组，它继承于Writer。操作的数据是以字符为单位！<br>3.PipedWriter 是字符类型的管道输出流。它和PipedReader一起是可以通过管道进行线程间的通讯。在使用管道通信时，必须将PipedWriter和PipedWriter配套使用。<br>4.FilterWriter 是字符类型的过滤输出流。<br>5.BufferedWriter 是字符缓冲输出流。它的作用是为另一个输出流添加缓冲功能。<br>6.OutputStreamWriter 是字节转字符的输出流。它是字节流通向字符流的桥梁：它使用指定的 charset 将字节转换为字符并写入。<br>7.FileWriter 是字符类型的文件输出流。它通常用于对文件进行读取操作。<br>8.PrintWriter 是字符类型的打印输出流。它是用来装饰其它输出流，能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。</p>
<blockquote>
<p>字节流与字符流的区别</p>
<ul>
<li>字节流在操作时本身不会用到缓冲区（内存），是文件本身直接操作的</li>
<li>字符流在操作时使用了缓冲区，通过缓冲区再操作文</li>
</ul>
</blockquote>
<h4 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h4><blockquote>
<p>在读取文件时会涉及I/O操作，在发送和接收网络数据时也会涉及IO操作。所有涉及到I/O的操作都要直接或者间接的经过内核程序。网络传输数据，首先是内核先接收到数据，然后内核将数据拷贝到用户态中供应用进程使用。这里使用网络I/O进行演示。</p>
</blockquote>
<p>阻塞与非阻塞指的是当不能进行读写（网卡满时的写/网卡空的时候的读）的时候，I/O 操作立即返回还是阻塞；<strong>阻塞/非阻塞关注的是程序（线程）等待消息通知时的状态</strong><br>同步异步指的是，当数据已经ready的时候，读写操作是同步读还是异步读。<strong>同步与异步主要是从消息通知机制角度来说的</strong>。异步的概念和同步相对。当一个同步调用发出后，调用者要一直等待返回消息（结果）通知后，才能进行后续的执行；当一个异步过程调用发出后，调用者不能立刻得到返回消息（结果）。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p>
<p>a.同步阻塞形式, 效率是最低的;<br>b.同步非阻塞形式，实际上是效率低下的，这个程序需要在这两种不同的行为之间来回的切换；<br>c.异步非阻塞形式，效率更高，程序没有在两种不同的操作中来回切换；</p>
<p><strong>5种IO模型</strong><br>1.同步阻塞I/O</p>
<blockquote>
<p>最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。<br>在应用进程通过内核调用recvfrom（）函数，其系统调用直到数据包到达且被复制到应用进程的缓冲区或者发生错误时才会返回，在此期间会一直等待。</p>
</blockquote>
<p>2.同步非阻塞I/O</p>
<blockquote>
<p>应用系统还是调用recvfrom，但是他不会阻塞于此，而是不断的去轮询的是否有数据准备好，如果没有准备好，就直接返回一个EWOULDBLOCK错误。<code>这个过程通常被称之为轮询</code>。轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。<strong>需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态</strong>。
与同步阻塞I/O相比，如果数据未准备好，不会一直阻塞与此，而是直接返回错误，接收到错误之后，就可以干点别的事，这是他的优点。但是缺点也很明显，任务完成的响应延迟增大了。因为很可能在两次轮询之间，socketfd就处于read状态了，所以导致整体的吞吐量下降了。</p>
</blockquote>
<p>3.I/O复用</p>
<blockquote>
<p>由于同步非阻塞方式需要不断主动轮询，轮询占据了很大一部分过程，轮询会消耗大量的CPU时间，而 “后台” 可能有多个任务在同时进行，人们就想到了循环查询多个任务的完成状态，只要有任何一个任务完成，就去处理它。如果轮询不是进程的用户态，而是有人帮忙就好了。那么这就是所谓的 “IO 多路复用”。UNIX/Linux 下的 select、poll、epoll 就是干这个的（epoll 比 poll、select 效率高，做的事情是一样的）。</p>
</blockquote>
<p>4.信号驱动I/O</p>
<blockquote>
<p>首先开启套接字信号驱动I/O功能，并通过系统调用sigaction执行一个信号处理函数，此时系统继续运行，并不会阻塞。当数据准备就绪时，就为该进程生成一个SIGIO信号，通过信号回调通知，通知应用进程调用recvfrom来读取数据。</p>
</blockquote>
<p>5.异步非阻塞I/O</p>
<blockquote>
<p>相对于同步IO，异步IO不是顺序执行。<code>用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情</code>。等到socket数据准备好了，内核直接复制数据给进程，<code>然后从内核向进程发送通知</code>。<code>IO两个阶段，进程都是非阻塞的</code>。</p>
</blockquote>
<p><strong>Collection 和 Collections 有什么区别？</strong><br>java.util.Collection 是一个集合接口。Collections则是集合类的一个工具类</p>
<p><strong>Array 和 ArrayList 有何区别？</strong><br>Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。 Array大小是固定的，ArrayList的大小是动态变化的。</p>
<p><strong>在 Queue 中 poll()和 remove()有什么区别？</strong></p>
<blockquote>
<p>1.queue的增加元素方法add和offer的区别在于，add方法在队列满的情况下将选择抛异常的方法来表示队列已经满了，而offer方法通过返回false表示队列已经满了；在有限队列的情况，使用offer方法优于add方法；<br>2.remove方法和poll方法都是删除队列的头元素，remove方法在队列为空的情况下将抛异常，而poll方法将返回null；<br>3.element和peek方法都是返回队列的头元素，但是不删除头元素，区别在与element方法在队列为空的情况下，将抛异常，而peek方法将返回null.</p>
</blockquote>
<p><strong>如何实现对象克隆？</strong></p>
<ol>
<li>实现Cloneable接口并重写Object类中的clone()方法；</li>
<li>实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆</li>
</ol>
<p><strong>throw 和 throws 的区别？</strong><br>throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> <span class="keyword">throws</span> Exception</span>&#123;&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"a的值大于0，不符合要求"</span>);</span><br></pre></td></tr></table></figure>

<p><strong>final、finally、finalize 有什么区别？</strong></p>
<p>java中，final可以用来修饰类，方法和变量（成员变量或局部变量）。当用final修饰类的时，表明该类不能被其他类所继承。当我们需要让一个类永远不被继承，此时就可以用final修饰，但要注意：final类中所有的成员方法都会隐式的定义为final方法。</p>
<p>使用final方法的原因主要有两个：<br>(1) 把方法锁定，以防止继承类对其进行更改。<br>(2) 效率，在早期的java版本中，会将final方法转为内嵌调用。但若方法过于庞大，可能在性能上不会有多大提升。因此在最近版本中，不需要final方法进行这些优化了。<br>final方法意味着“最后的、最终的”含义，即此方法不能被重写。</p>
<p>final成员变量表示常量，只能被赋值一次，赋值后其值不再改变。类似于C++中的const。<br>当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化；如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。本质上是一回事，因为引用的值是一个地址，final要求值，即地址的值不发生变化。<br>final修饰一个成员变量（属性），必须要显示初始化。这里有两种初始化方式，一种是在变量声明的时候初始化；第二种方法是在声明变量的时候不赋初值，但是要在这个变量所在的类的所有的构造函数中对这个变量赋初值。</p>
<p>finally作为异常处理的一部分，它只能用在try/catch语句中，并且附带一个语句块，表示这段语句最终一定会被执行（不管有没有抛出异常），经常被用在需要释放资源的情况下。</p>
<p>finalize()是在java.lang.Object里定义的，也就是说每一个对象都有这么个方法。这个方法在gc启动，该对象被回收的时候被调用。其实gc可以回收大部分的对象（凡是new出来的对象，gc都能搞定，一般情况下我们又不会用new以外的方式去创建对象），所以一般是不需要程序员去实现finalize的。</p>
<p><strong>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</strong><br>会执行，在return 前执行</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/JavaBasics/">JavaBasics</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2019/10/25/Java-JDK/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Java-JDK</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2019/10/15/Java中的T-E-K-V/">
        <span class="next-text nav-default">Java中的T,E,K,V</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2019
    <span class="footer-author">yaoper.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a> and <a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
