<!DOCTYPE html>
<html lang>
  <head><meta name="generator" content="Hexo 3.9.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="高性能MySQL读书笔记第五章">




  <meta name="keywords" content="MySQL,">





  <link rel="alternate" href="/default" title="Illusory">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1">



<link rel="canonical" href="http://yaoper.github.io/2020/03/26/高性能MySQL读书笔记（第五章）/">


<meta name="description" content="5. 创建高性能的索引索引对于良好的性能非常关键，尤其是当表中的数据量越来越大的时候，索引对性能的影响愈发重要。索引优化应该是对查询性能优化最有效的手段。 5.1 索引基础5.1.1 索引的类型B-Tree索引大多数的MySQL都支持B-Tree索引，如果没有特别指出，我们讨论索引都是在说B-Tree索引。B-Tree索引意味着所有的值都是按照顺序存储的，并且每一个叶子也到根的距离相同。 B-Tr">
<meta name="keywords" content="MySQL">
<meta property="og:type" content="article">
<meta property="og:title" content="高性能MySQL读书笔记第五章">
<meta property="og:url" content="http://yaoper.github.io/2020/03/26/高性能MySQL读书笔记（第五章）/index.html">
<meta property="og:site_name" content="Illusory">
<meta property="og:description" content="5. 创建高性能的索引索引对于良好的性能非常关键，尤其是当表中的数据量越来越大的时候，索引对性能的影响愈发重要。索引优化应该是对查询性能优化最有效的手段。 5.1 索引基础5.1.1 索引的类型B-Tree索引大多数的MySQL都支持B-Tree索引，如果没有特别指出，我们讨论索引都是在说B-Tree索引。B-Tree索引意味着所有的值都是按照顺序存储的，并且每一个叶子也到根的距离相同。 B-Tr">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://www.imageoss.com/images/2020/03/12/20200312220353.png">
<meta property="og:image" content="https://www.imageoss.com/images/2020/03/12/20200312220809.png">
<meta property="og:image" content="https://www.imageoss.com/images/2020/03/12/20200312221106.png">
<meta property="og:updated_time" content="2020-03-26T04:05:34.676Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="高性能MySQL读书笔记第五章">
<meta name="twitter:description" content="5. 创建高性能的索引索引对于良好的性能非常关键，尤其是当表中的数据量越来越大的时候，索引对性能的影响愈发重要。索引优化应该是对查询性能优化最有效的手段。 5.1 索引基础5.1.1 索引的类型B-Tree索引大多数的MySQL都支持B-Tree索引，如果没有特别指出，我们讨论索引都是在说B-Tree索引。B-Tree索引意味着所有的值都是按照顺序存储的，并且每一个叶子也到根的距离相同。 B-Tr">
<meta name="twitter:image" content="https://www.imageoss.com/images/2020/03/12/20200312220353.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1">
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> 高性能MySQL读书笔记第五章 - Illusory </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">Illusory</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          高性能MySQL读书笔记第五章
        
      </h1>

      <time class="post-time">
          Mar 26 2020
      </time>
    </header>



    
            <div class="post-content">
            <h3 id="5-创建高性能的索引"><a href="#5-创建高性能的索引" class="headerlink" title="5. 创建高性能的索引"></a>5. 创建高性能的索引</h3><p>索引对于良好的性能非常关键，尤其是当表中的数据量越来越大的时候，索引对性能的影响愈发重要。索引优化应该是对查询性能优化最有效的手段。</p>
<h4 id="5-1-索引基础"><a href="#5-1-索引基础" class="headerlink" title="5.1 索引基础"></a>5.1 索引基础</h4><h5 id="5-1-1-索引的类型"><a href="#5-1-1-索引的类型" class="headerlink" title="5.1.1 索引的类型"></a>5.1.1 索引的类型</h5><h6 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h6><p>大多数的MySQL都支持B-Tree索引，如果没有特别指出，我们讨论索引都是在说B-Tree索引。B-Tree索引意味着所有的值都是按照顺序存储的，并且每一个叶子也到根的距离相同。</p>
<p>B-Tree索引能够加快访问数据的速度是因为存储引擎不再需要进行全表扫描来获取数据而是从索引的根节点开始进行搜索。B-Tree对索引列是顺序组织存储的，所以很适合查找范围数据。</p>
<h6 id="可以使用B-Tree索引的查询类型"><a href="#可以使用B-Tree索引的查询类型" class="headerlink" title="可以使用B-Tree索引的查询类型"></a>可以使用B-Tree索引的查询类型</h6><p>B-Tree索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找。</p>
<p>全值匹配</p>
<p>匹配最左前缀</p>
<p>匹配列前缀</p>
<p>精确匹配某一列并范围匹配另外一列</p>
<p>只访问索引的查询（覆盖索引）</p>
<h6 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h6><p>哈希索引是基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有索引列计算出一个哈希码，哈希码是一个比较小的值，并且不同键值得行计算出来的哈希码也不一样。</p>
<p>MySQL中只有Memory引擎显式支持哈希索引。因为哈希索引自身只需要存储对于的哈希值，所以索引的结构十分的紧凑。然而哈希索引也有它的限制：</p>
<ul>
<li>哈希索引只包含哈希值和行指针，而不存储字段值，所以不可避免的需要回表。但因内存中（Memory引擎）行的读取速度很快，所以这一点基本可以忽略。</li>
<li>哈希索引数据并不是按照索引值的顺序存储的，所以无法用于排序。</li>
<li>哈希索引也不支持部分索引列匹配查找，因为哈希索引始终使用的是索引列的哈希值。</li>
<li>哈希索引只支持等值比较查询（=，in,&lt;==&gt;），不支持范围查询。</li>
<li>如果哈希冲突很多的话，一些索引维护操作会付出很高的代价。</li>
</ul>
<p>InnoDB是存储引擎有个特殊的功能叫“自适应哈希索引”，当InnoDB发现某些索引值被使用的非常频繁时，会在内存里面基于B-Tree创建一个哈希索引。这是一个完全自动化的，内部行为，用户无法控制或者配置，不过可以关闭该功能。</p>
<p>一个例子，如果存储大量的网站URL，并且需要根据URL进行搜索，可以使用一个叫做url_crc的列做索引，使用CRC32做哈希，方便查询。</p>
<h6 id="空间数据索引（R-Tree）"><a href="#空间数据索引（R-Tree）" class="headerlink" title="空间数据索引（R-Tree）"></a>空间数据索引（R-Tree）</h6><p>MyISAM表支持空间索引，可以用作地理数据存储。MySQL对GIS支持并不完善，推荐PostgreSQL或者Redis。</p>
<h6 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h6><p>全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较所以中的值，后面的章节会详细介绍。</p>
<h6 id="其他索引类型"><a href="#其他索引类型" class="headerlink" title="其他索引类型"></a>其他索引类型</h6><p>TokuDB的分形树索引，是一种较新开发的数据结构，继承了B-Tree的许多优点也避免了缺点；还有ScaleDB的Patricia tries等索引。</p>
<h4 id="5-2-索引的优点"><a href="#5-2-索引的优点" class="headerlink" title="5.2 索引的优点"></a>5.2 索引的优点</h4><p>总结起来索引的优点如下：</p>
<ol>
<li>索引大大减少了服务器需要扫描的数据量。</li>
<li>索引可以帮助服务器避免排序和临时表。</li>
<li>索引可以将随机IO变为顺序IO。</li>
</ol>
<h4 id="5-3-高性能的索引策略"><a href="#5-3-高性能的索引策略" class="headerlink" title="5.3 高性能的索引策略"></a>5.3 高性能的索引策略</h4><h5 id="5-3-1-独立的列"><a href="#5-3-1-独立的列" class="headerlink" title="5.3.1 独立的列"></a>5.3.1 独立的列</h5><p>独立的列是指索引列不能是表达式的一部分，也不能是函数的参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">× select * from students where age+<span class="number">1</span>=<span class="number">10</span>;</span><br><span class="line">√ select * from students where age=<span class="number">11</span>;</span><br><span class="line">× select * <span class="function">from students where <span class="title">to_days</span><span class="params">(create_time)</span> - <span class="title">to_days</span><span class="params">(login_time)</span></span>=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h5 id="5-3-2-前缀索引和索引选择性"><a href="#5-3-2-前缀索引和索引选择性" class="headerlink" title="5.3.2 前缀索引和索引选择性"></a>5.3.2 前缀索引和索引选择性</h5><p>索引的选择性是值，不重复的索引值与数据表的记录总数的比值，范围从1/T到1之间。索引的选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p>
<p>对于BLOB或者TEXT后者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。选择合适的前缀的长度，使得前缀索引的选择性接近于索引整个列。前缀索引的缺点是无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。</p>
<h5 id="5-3-3-多列索引"><a href="#5-3-3-多列索引" class="headerlink" title="5.3.3 多列索引"></a>5.3.3 多列索引</h5><p>为每个列创建独立的索引并不能提升性能问题，反而可能会带来性能问题。</p>
<p>MySQL5.0引入的索引合并会优化复杂的查询，但是实际上更多时候说明表上的索引建的很糟糕：</p>
<ul>
<li>当出现服务器对多个索引做相交叉操作时，通常意味着需要建一个包含所有相关列的多列索引，而不是多个独立的索引列。</li>
<li>当服务器需要对多个索引做联合操作是，通常需要耗费大量的CPU和内存资源在算法的缓存、排序和合并操作上。</li>
<li>更重要的是，优化器不会把这些计算到“查询成本”中，优化器只关心随机页面读取；这会使得查询成本被低估，导致该执行计划甚至不如走全表扫描。</li>
</ul>
<p>可以通过参数optimizer_switch来关闭索引合并功能。也可以用过ignore index提示让优化器忽略调某些索引。</p>
<h5 id="5-3-4-选择合适的索引列顺序"><a href="#5-3-4-选择合适的索引列顺序" class="headerlink" title="5.3.4 选择合适的索引列顺序"></a>5.3.4 选择合适的索引列顺序</h5><p>正确的顺序依赖于使用该索引的查询，并且同时需要考虑如何更好的满足排序和分组的需要。经验法则：将选择性最高的列放到索引最前列（当不需要考虑排序和分组时是最好的选择）。</p>
<h5 id="5-3-5-聚簇索引"><a href="#5-3-5-聚簇索引" class="headerlink" title="5.3.5 聚簇索引"></a>5.3.5 聚簇索引</h5><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。当表有聚簇索引时，它的数据实际上存放在索引的叶子页中。因为存储引擎负责实现索引，所以不是所有的存储引擎都支持聚簇索引。InnoDB通过主键聚集数据，如果美哦与主键，InnoDB会选择一个唯一的非空索引代替，如果没有这样的索引，InnoDB会隐式的定义一个主键来作为聚簇索引。</p>
<p>优点：</p>
<ul>
<li>可以把相关数据保存在一起。</li>
<li>数据访问速度更快。</li>
<li>使用覆盖索引扫描查询可以直接使用页节点中的主键值。</li>
</ul>
<p>缺点：</p>
<ul>
<li>聚簇数据最大限度地提高了IO密集型应用的性能，但是如果数据全部都放在内存里，则访问的顺序就没那么重要了，聚簇索引也就没什么优势。</li>
<li>插入速度严重依赖插入顺序。按照主键的顺序插入是加载数据到InnoDB表中最快的方式。</li>
<li>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。</li>
<li>基于聚簇索引的表在插入新行或者主键被更新导致的移动的时候，可能面临“页分裂”的问题。</li>
<li>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。</li>
<li>二级索引（非聚簇）可能比想象的要更大，因为叶子节点要包含引用行的主键列。</li>
<li>二级索引访问需要两次索引查找，而不是一次（俗称回表）。</li>
</ul>
<p>为什么会回表，因为二级索引保存的是行的主键，而不是指向行的物理位置的指针，所以需要回表查询。</p>
<h6 id="InnoDB和MyISAM的数据分布对比"><a href="#InnoDB和MyISAM的数据分布对比" class="headerlink" title="InnoDB和MyISAM的数据分布对比"></a>InnoDB和MyISAM的数据分布对比</h6><p>MyISAM按照数据插入的顺序存储在磁盘上，如果所示：</p>
<p><img src="https://www.imageoss.com/images/2020/03/12/20200312220353.png" alt="20200312220353.png"></p>
<p>事实上，MyISAM中主键索引和其他索引在结构上没有什么不同，主键索引就是一个名称为Primary的唯一非空索引。</p>
<p>InnoDB因为支持聚簇索引，所以使用了非常不通的方式来存储同样的数据，如下图所示：</p>
<p><img src="https://www.imageoss.com/images/2020/03/12/20200312220809.png" alt="20200312220809.png"></p>
<p>聚簇索引的每一个叶子节点都包含了主键值、事务ID、MVCC的回滚指针以及所有剩余列。还有一点不同的是，InnoDB的二级索引的叶子节点中存储的不是“行指针”，而是主键值。</p>
<p><img src="https://www.imageoss.com/images/2020/03/12/20200312221106.png" alt="20200312221106.png"></p>
<h6 id="在InnoDB表中按主键顺序插入行"><a href="#在InnoDB表中按主键顺序插入行" class="headerlink" title="在InnoDB表中按主键顺序插入行"></a>在InnoDB表中按主键顺序插入行</h6><p>可以定义一个代理主键作为主键，这个主键的数据应和应用无关，最简单的方式是使用auto_increment自增列，来保证数据是顺序写入的。最好避免随机的聚簇索引，特别是对于IO密集型的应用。</p>
<p>顺序的主键造成的性能问题？在高并发的时候，InnoDB中按照主键顺序插入可能造成争抢，主键的上届会成为一个热点，另外一个热点可能是auto_increment锁机制。如果遇到这样的问题，可以考虑更改innodb_autoinc_lock_mode配置。</p>
<h5 id="5-3-6-覆盖索引"><a href="#5-3-6-覆盖索引" class="headerlink" title="5.3.6 覆盖索引"></a>5.3.6 覆盖索引</h5><p>索引包含所有需要查询的字段的值，我们就称之为覆盖索引。覆盖索引能极大的提高性能，而无需回表。因为：</p>
<ul>
<li>索引条目通常远远小于数据行大小，所以如果只需要读取索引，那么MySQL就会极大的减少数据访问量。</li>
<li>因为索引是按照列值顺序存储的，所以对于IO密集型的范围查询会比随机从磁盘读取每一行数据的IO要少得多。</li>
<li>MyISAM引擎在内存中缓存索引，数据则依赖操作系统缓存，因此访问数据需要一次系统调用。</li>
<li>由于InnoDB的聚簇索引，覆盖索引对InnoDB特别有帮助，可以避免对主键索引的二次查询。</li>
</ul>
<p>不是所有的索引都能成为覆盖索引，这时候看可以对索引进行优化或者对SQL进行修改使用延迟关联来使用覆盖索引。</p>
<h5 id="5-3-7-使用索引扫描来做排序"><a href="#5-3-7-使用索引扫描来做排序" class="headerlink" title="5.3.7 使用索引扫描来做排序"></a>5.3.7 使用索引扫描来做排序</h5><p>MySQL可以使用同一个索引既满足排序有用于查找行，如果有可能，在设计索引时尽量同时满足这两个任务。当explian出来的type列的值为index，则说明MySQL使用了索引列扫描来做排序了。</p>
<p>只有当索引的列的顺序和排序语句的顺序完全一致，且所有列的排序方向一样，MySQL才能够使用索引来对结果进行排序。如果查询需要关联多张表，只有当排序子句引用的字段都是第一个表时，才能使用索引做排序。否则MySQL都需要执行排序操作而无法利用索引排序。</p>
<h5 id="5-3-8-前缀压缩索引"><a href="#5-3-8-前缀压缩索引" class="headerlink" title="5.3.8 前缀压缩索引"></a>5.3.8 前缀压缩索引</h5><p>MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引放到内存中，这样可以优化性能。默认只压缩字符串，但是通过调参也可以压缩整数。</p>
<p>MyISAM压缩每个索引块的方法是先完全保存索引块的第一个值，然后将其他值和第一个进行比较得到相同前缀的字节数和剩余不同后缀部分，把这部分存储起来即可。压缩块使用了更少的空间，代价是一些操作可能更慢，所以MyISAM的二分查找只能从头开始，倒序的order by desc的性能也不是很好。</p>
<h5 id="5-3-9-冗余和重复索引"><a href="#5-3-9-冗余和重复索引" class="headerlink" title="5.3.9 冗余和重复索引"></a>5.3.9 冗余和重复索引</h5><p>重复索引是值在相同的列上按照相同的顺序创建多个相同类型的索引。应该尽量避免这样，发现以后要及时删除。</p>
<p>冗余索引和重复索引有一些不同，通常发生在为表添加新索引的时候。大多数情况下都不需要冗余索引，应该尽量扩展已有的索引而不是创建新索引。也有例外，数据量比较大扩展原索引有性能问题，而不得不创建新索引。</p>
<p>解决重复索引和冗余索引的方法就是删除之。可以使用从工具如common_schema或者pt-duplicate-key-checker来分析和定位重复索引冗余索引。</p>
<h5 id="5-3-10-未使用的索引"><a href="#5-3-10-未使用的索引" class="headerlink" title="5.3.10 未使用的索引"></a>5.3.10 未使用的索引</h5><p>这样的索引完全是累赘，直接删除之。借助工具pt-index-usage或者MariaDB打开userstates通过查询information_schema.index_statistics查询使用频率。</p>
<h5 id="5-3-11-索引和锁"><a href="#5-3-11-索引和锁" class="headerlink" title="5.3.11 索引和锁"></a>5.3.11 索引和锁</h5><p>使用索引可以让查询锁定更少的行。InnoDB虽然行锁效率很高，但是锁定行的时候还是会带来额外的开销，其次锁定的行超过需要的行的时候会增加锁争用减少并发性。但这是有当InnoDB在存储引擎层能够过滤掉所有不需要的行才有效，如果无法过滤掉，存储引擎层把数据返回给服务器层来通过where子句过滤，这个时候已经无法避免锁定多余的行了。因为InnoDB已经锁定了这些行，在合适的时候才会释放。在MySQL5.1版本中，InnoDB可以在服务器层过滤掉行后就释放锁，早期版本要事务提交才释放。</p>
<p>InnoDB在二级索引上使用共享锁，但是访问主键索引使用排它锁。这消除了使用覆盖索引的可能性，并且使得select for update比lock in share mode或非锁定查询要慢很多。</p>
<h4 id="5-4-索引案例学习"><a href="#5-4-索引案例学习" class="headerlink" title="5.4 索引案例学习"></a>5.4 索引案例学习</h4><h5 id="5-4-1-支持多种过滤条件"><a href="#5-4-1-支持多种过滤条件" class="headerlink" title="5.4.1 支持多种过滤条件"></a>5.4.1 支持多种过滤条件</h5><h5 id="5-4-2-避免多个范围条件"><a href="#5-4-2-避免多个范围条件" class="headerlink" title="5.4.2 避免多个范围条件"></a>5.4.2 避免多个范围条件</h5><h5 id="5-4-3-优化排序"><a href="#5-4-3-优化排序" class="headerlink" title="5.4.3 优化排序"></a>5.4.3 优化排序</h5><p>优化排序的一个好的办法是限制用户能够翻页的数量，因为10000页的结果多用户来说意义不大；另外一个比较好的额策略就是使用延迟关联，通过覆盖索引查询返回需要的主键，再根据这些主键关联原表获得需要的行。</p>
<h4 id="5-5-维护索引和表"><a href="#5-5-维护索引和表" class="headerlink" title="5.5 维护索引和表"></a>5.5 维护索引和表</h4><p>维护表的三个主要目的：找到并修复损坏的表，维护准确的索引信息，减少碎片。</p>
<h5 id="5-5-1-找到并修复损坏的表"><a href="#5-5-1-找到并修复损坏的表" class="headerlink" title="5.5.1 找到并修复损坏的表"></a>5.5.1 找到并修复损坏的表</h5><p>针对MyISAM存储引擎，check table可以检查表是否损坏，repair table命令可以用来修复损坏的表。InnoDB引擎可以通过执行一个不做任何操作的命令来重建表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table innodb_tb engine=innodb;</span><br></pre></td></tr></table></figure>

<p>也可以使用一些存储引擎相关的离线工具。</p>
<h5 id="5-5-2-更新索引统计信息"><a href="#5-5-2-更新索引统计信息" class="headerlink" title="5.5.2 更新索引统计信息"></a>5.5.2 更新索引统计信息</h5><p>MySQL的查询优化器通过两个API来了解存储引擎的索引值分布信息，以决定如何使用索引。第一个API是records_in_range()，通过向存储引擎传两个边界值来获取这个范围大概有多少条记录，MyISAM返回精确值，InnoDB返回估算值。第二个API是info()，该结构返回各种类型的数据，包括所以的基数。</p>
<p>可以通过运行analyze table来重新生成统计信息。</p>
<h5 id="5-5-3-减少索引和数据碎片"><a href="#5-5-3-减少索引和数据碎片" class="headerlink" title="5.5.3 减少索引和数据碎片"></a>5.5.3 减少索引和数据碎片</h5><p>B-Tree索引可能会碎片化，这会降低查询的效率。碎片化的索引可能会以很差或者无序的方式存储在磁盘上。根据设计，B-Tree需要随机访问磁盘才能定位到叶子页，所以随机访问是不可避免的。然而，如果叶子页在物理上分布是顺序且紧密的，那么查询的性能就会更好。否则，对于范围查询，索引覆盖扫描来说速度可能会降低很多倍。</p>
<p>数据存储的碎片化有三种类型：行碎片、行间碎片、剩余空间碎片。对于MyISAM来说三种碎片都有可能发生，但InnoDB不会出现短小的行碎片。可以通过optimize table或者导出导入的方式来重新整理数据。</p>
<h5 id="5-6-总结"><a href="#5-6-总结" class="headerlink" title="5.6 总结"></a>5.6 总结</h5><p>在MySQL中，大多数情况下都会使用B-Tree索引。其他类型的索引大多只使用在特殊的场景。</p>
<p>在选择索引和设计索引的时候，要记住如下三个原则：</p>
<ol>
<li>单行访问是慢的。最好读取的块中能包含尽可能多需要的行。使用索引可以创建位置引用来提升效率。</li>
<li>按顺序访问范围数据是很快的，原因有二：1.顺序IO不需要多次磁盘寻道，比随机IO要快很多。2如果服务器能按照顺序读取数据，那么久不再需要额外的排序操作。</li>
<li>索引覆盖查询是很快的。因为不需要回表查找行，这就避免了大量的单行访问。</li>
</ol>
<p>理解索引是如何工作的非常重要，根据理解的原理来创建最合适的索引，而不是根据一些经验之谈来创建索引。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/MySQL/">MySQL</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2020/03/26/ZooKeeper-分布式应用的协调服务/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">ZooKeeper-分布式应用的协调服务</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2020/03/26/高性能MySQL读书笔记（第三章）/">
        <span class="next-text nav-default">高性能MySQL读书笔记第三章</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2020
    <span class="footer-author">yaoper.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a> and <a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
