<!DOCTYPE html>
<html lang>
  <head><meta name="generator" content="Hexo 3.9.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="高性能MySQL读书笔记第四章">




  <meta name="keywords" content="MySQL,">





  <link rel="alternate" href="/default" title="Illusory">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1">



<link rel="canonical" href="http://yaoper.github.io/2020/03/26/高性能MySQL读书笔记（第四章）/">


<meta name="description" content="4. Schema与数据类型优化良好的逻辑设计和物理设计是高性能的基石，应该根据系统将要执行的查询语句来设计schema，这往往需要权衡很多因素。 4.1 选择优化的数据类型选择正确的数据类型对于获得高性能至关重要，在选择的时候应该遵循以下几个原则： 更小的通常更好 一般情况下，应该尽量使用可以正确存储数据的最小数据类型，更小的数据类型通常会更快，因为它占用更少的磁盘，内存和CPU缓存，并且处理的">
<meta name="keywords" content="MySQL">
<meta property="og:type" content="article">
<meta property="og:title" content="高性能MySQL读书笔记第四章">
<meta property="og:url" content="http://yaoper.github.io/2020/03/26/高性能MySQL读书笔记（第四章）/index.html">
<meta property="og:site_name" content="Illusory">
<meta property="og:description" content="4. Schema与数据类型优化良好的逻辑设计和物理设计是高性能的基石，应该根据系统将要执行的查询语句来设计schema，这往往需要权衡很多因素。 4.1 选择优化的数据类型选择正确的数据类型对于获得高性能至关重要，在选择的时候应该遵循以下几个原则： 更小的通常更好 一般情况下，应该尽量使用可以正确存储数据的最小数据类型，更小的数据类型通常会更快，因为它占用更少的磁盘，内存和CPU缓存，并且处理的">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-03-26T04:05:34.772Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="高性能MySQL读书笔记第四章">
<meta name="twitter:description" content="4. Schema与数据类型优化良好的逻辑设计和物理设计是高性能的基石，应该根据系统将要执行的查询语句来设计schema，这往往需要权衡很多因素。 4.1 选择优化的数据类型选择正确的数据类型对于获得高性能至关重要，在选择的时候应该遵循以下几个原则： 更小的通常更好 一般情况下，应该尽量使用可以正确存储数据的最小数据类型，更小的数据类型通常会更快，因为它占用更少的磁盘，内存和CPU缓存，并且处理的">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1">
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> 高性能MySQL读书笔记第四章 - Illusory </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">Illusory</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          高性能MySQL读书笔记第四章
        
      </h1>

      <time class="post-time">
          Mar 26 2020
      </time>
    </header>



    
            <div class="post-content">
            <h3 id="4-Schema与数据类型优化"><a href="#4-Schema与数据类型优化" class="headerlink" title="4. Schema与数据类型优化"></a>4. Schema与数据类型优化</h3><p>良好的逻辑设计和物理设计是高性能的基石，应该根据系统将要执行的查询语句来设计schema，这往往需要权衡很多因素。</p>
<h4 id="4-1-选择优化的数据类型"><a href="#4-1-选择优化的数据类型" class="headerlink" title="4.1 选择优化的数据类型"></a>4.1 选择优化的数据类型</h4><p>选择正确的数据类型对于获得高性能至关重要，在选择的时候应该遵循以下几个原则：</p>
<p><strong>更小的通常更好</strong></p>
<p>一般情况下，应该尽量使用可以正确存储数据的最小数据类型，更小的数据类型通常会更快，因为它占用更少的磁盘，内存和CPU缓存，并且处理的时候需要的CPU周期也更少。</p>
<p><strong>简单就好</strong><br>简单的数据类型的造作通常需要更少的CPU周期。例如：整型比字符串的操作代价更低，使用MySQL内建类型而不是字符串来存储日期和时间，另外应该使用整型来存储IP地址。</p>
<p><strong>尽量避免NULL</strong></p>
<p>如果查询语句中包含可为NULL的列，对MySQL来说更难优化。因为可为NULL的列使得索引，索引统计和值比较更复杂。可为NULL的列会使用更多的存储空间，在MySQL里面需要特殊处理。可为NULL的列别索引时，每个索引需要一个额外的字节。</p>
<p>通常把可为NULL的列改为NOT NULL带来的性能提升比较小，所以调优没有必要首先在现有Schema中查找并修改掉这种情况，除非确定是这里导致的问题。但是如果计划在该列上建立索引，就应该尽量避免设计成这样。</p>
<p>InnoDB使用单独的bit存储NULL值，所以对于稀疏数据有很好的空间效率，这一点对MyISAM不适用。</p>
<p>在为列选择数据类型时，第一步需要确定合适的大类型：数字，字符串，时间等。然后是选择根据存储的长度，范围，精度或者是物理存储空间的不同选择合适的具体类型。</p>
<p>Datetime和Timestamp都可以存储日期时间，并且都精确到秒。但是Timestamp只使用Datetime一半的存储空间，并且会根据时区变化，但是Timestamp允许的时间范围到2038年，比Datetime要小的多。</p>
<h5 id="4-1-1-整数类型"><a href="#4-1-1-整数类型" class="headerlink" title="4.1.1 整数类型"></a>4.1.1 整数类型</h5><table>
<thead>
<tr>
<th>名称</th>
<th>字节</th>
<th>位</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>tinyint</td>
<td>1</td>
<td>8</td>
<td>-2^7~2^7-1</td>
</tr>
<tr>
<td>smallint</td>
<td>2</td>
<td>16</td>
<td>-2^15~2^15-1</td>
</tr>
<tr>
<td>mediumint</td>
<td>2.5</td>
<td>24</td>
<td>-2^23~2^23-1</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>32</td>
<td>-2^31~2^31-1</td>
</tr>
<tr>
<td>bigint</td>
<td>8</td>
<td>64</td>
<td>-2^63~2^63-1</td>
</tr>
</tbody></table>
<p>整数类型有可选的unsigned属性，表示不允许复制，这大致可以使正数的上限提高一倍。有符号和无符号类型使用相同的存储空间，并具备相同的性能。</p>
<p>选择决定的只是MySQL在内存和磁盘中的存储，而计算一般使用的是64位的bigint，即时在32位的环境下也是如此。MySQL可以为整数类型指定宽度，如int(11)，对于大多数应用来说这是没有意义的：它不会限制值得合法范围，只是规定了MySQL的一些交互工具用来显示字符的个数。对于存储来说int(1)和int(20)是相同的。</p>
<h5 id="4-1-2-实数类型"><a href="#4-1-2-实数类型" class="headerlink" title="4.1.2 实数类型"></a>4.1.2 实数类型</h5><p>实数是带有小数点部分的数字，然而它们不只是为了存储小数部分；也可以使用decimal存储比bigint还大的整数。MySQL既支持精确类型也支持不精确类型。</p>
<p>float和double类型支持使用标准的浮点运算进行的近似计算。decimal类型用户存储精确的小数。MySQL5.0以后的版本中，decimal类型支持精确计算。MySQL4.1以及更早的版本使用浮点运算来实现decimal的计算。</p>
<p>decimal将数字打包保存到一个二进制字符串中（每4个字节存9个数字），例如decimal（18,9）小数点两边各存储9个数字，一共使用9个字节（小数点本身单独占用一个字节）。MySQL5.0以上版本中decimal类型允许最多存65个数字，之前的版本是254个数字，因为实际用不到这么大的数字。</p>
<p>在存储同样范围的数时浮点类型通常比decimal使用更少的空间，float使用4个字节存储，double使用8个字节存储。</p>
<p>因为需要额外的空间和计算开销，所以应该尽量只在对小数进行精确计算时候才使用decimal。在数据量比较大的时候可以考虑使用bigint代替decimal，将需要存储的货币单位根据小数位数乘以相应的倍数即可。</p>
<h5 id="4-1-3-字符串类型"><a href="#4-1-3-字符串类型" class="headerlink" title="4.1.3 字符串类型"></a>4.1.3 字符串类型</h5><p><strong>varchar和char类型</strong></p>
<p>varchar和char是两种主要的字符串类型，在磁盘和内存中如何存储很难单独说清楚，这主要跟存储引擎的具体实现有关系。</p>
<p><strong>varchar</strong></p>
<p>varchar用于存储可变长字符串，是最常见的字符串数据类型。它比定长类型更节省空间。例外，如果表使用的row_format=fixed创建的话，每一行都会使用定长存储，这样会浪费空间。</p>
<p>varchar需要使用1或2个额外的字节记录字符串的长度，如果列的最大长度小于等于255字节则使用1个字节表示，否者使用2个字节记录长度。</p>
<p>varchar节省了空间所以对性能提升有帮助，但是由于是变长的，在update时可能使行变得比原来更长，也可能带来一些问题。如果一个行占用的空间增长并且在页内没有更多的空间可以存储，MyISAM会将行拆成片段存储，InnoDB则需要分裂页来使行可以放进页内。</p>
<p>一些适合使用varchar的场景：1.字符串列的最大长度比平均长度大很多；2.列很少更新，不容易产生碎片；3.使用了UTF-8这样复杂的字符集</p>
<p>MySQL5.X及其以上在存储和检索的时候会保留末尾的空格，但是在MySQL4.1以及更早的版本会剔除末尾的空格。</p>
<p>InnoDB在存储过长的varchar时会转换为blob来进行存储。</p>
<p><strong>char</strong></p>
<p>char类型是固定长度的字符串，MySQL会根据定义的长度来分配足够的空间；不一样的，MySQL各个版本会删除末尾的空格来存储。</p>
<p>char特别适合存储很短的字符串，后者所有长度接近同一个值得字符串。比如适合存储MD5的密码，因为他们是同样的长度。对于经常变更的数据，char也比varchar更合适，因为char类型不容易产生碎片。对于非常短的列，char在存储空间上也更有效率。因为varchar还需要额外的1字节来存储长度。</p>
<p>与char和varchar类似的还有binary和varbinary，他们存储的是二进制字符串。</p>
<p><strong>blob和text类型</strong></p>
<p>它们是为了存储很大的数据而设计的字符串数据类型，分别采用二进制和字符串方式存储。与其他类型不同的是MySQL把每个blob和text值当做一个独立的对象处理。存储引擎在存储时通常会做特殊处理。当blob和text值太大时，InnoDB会使用专门的外部存储区域来今次那个存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值。</p>
<p>blob和text的区别是前者存储的是二进制数据，没有排序规则或者字符集，后者是有字符集和排序规则的。MySQL对blob和text进行排序与其他类型不同：它只对每个列的最前max_sort_length字节而不是整个字符串做排序。</p>
<p><strong>使用枚举类型代替字符串</strong></p>
<p>某些场景下可以使用枚举类型代替常用的字符串类型，枚举列可以把一些不重复的字符串存储成一个预定义的集合。MySQL在存储枚举时非常紧凑，会根据列表值得数量压缩到一个或者两个字节中，在MySQL的内部会将每个值在列表中的未知保存为整数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select e+<span class="number">0</span> fro enum_test;</span><br><span class="line">+-------+</span><br><span class="line">|  e+<span class="number">0</span>  |</span><br><span class="line">+-------+</span><br><span class="line">|   <span class="number">1</span>   |</span><br><span class="line">|   <span class="number">2</span>   |</span><br><span class="line">|   <span class="number">3</span>   |</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure>

<p>枚举不好的地方是字符串列表是固定的，添加或者杀出字符串必须使用alter table，因此对于未来可变的字符串来说使用枚举并不是一个很好的选择，除非能接受只在列表末尾添加元素。由于把枚举保存为整数，并且必须进行查询才能转换为字符串，所以枚举有些小小的开销。通常请款下开销可控，但是在某些场景使用char或varchar列与枚举列进行关联可能会比直接关联char或varchar列更慢。</p>
<h5 id="4-1-4-日期和时间类型"><a href="#4-1-4-日期和时间类型" class="headerlink" title="4.1.4 日期和时间类型"></a>4.1.4 日期和时间类型</h5><p>MySQL能存储的最小时间粒度为秒。MySQL提供两种相似的日期类型：datetime和timestamp。</p>
<p><strong>Datetime</strong></p>
<p>存储范围从1001-9999年，精度为秒，与时区无关，使用8个字节的存储空间。</p>
<p><strong>Timestamp</strong></p>
<p>保存了从格林尼治标准时间以来的秒数，它和UNIX时间戳相同。timestamp只使用4个字节的存储空间，因此它的范围比datetime小的多，只能表示从1970年到2038年。可以使用from_unixtime()函数把Unix时间戳转换为日期，也可以使用nuix_timestamp()函数把日期转换成Unix时间戳。</p>
<p>timestamp显示的值也依赖于时区，如果没有特殊的要求应尽量使用timestamp来存储时间，因为它的datetime空间效率更高。不推荐将Unix时间戳转换成整数来存储，效率上不能带来提升，通常在格式上处理很不方便。</p>
<p>如果需要存储比秒粒度更少的日期和时间怎么办？可以使用bigint类型来存储微妙级别的时间戳或者使用double存储秒之后的小数部分。</p>
<h5 id="4-1-5-位数据类型"><a href="#4-1-5-位数据类型" class="headerlink" title="4.1.5 位数据类型"></a>4.1.5 位数据类型</h5><p><strong>bit</strong></p>
<p>MySQL把bit当做字符串类型，而不是数字类型。大部分场景下不建议使用bit类型。</p>
<p><strong>set</strong></p>
<p>如果需要保存很多true/false值，可以考虑合并这些列到一个set数据类型，它在MySQL内部以一系列的位的集合来表示。这样能有效的利用存储空间，但是不能在set列上使用索引，不推荐使用。</p>
<p><strong>在整数列上进行按位操作</strong></p>
<p>替代set的方式是使用一个整数包装一系列的位。</p>
<h5 id="4-1-6-选择标识符"><a href="#4-1-6-选择标识符" class="headerlink" title="4.1.6 选择标识符"></a>4.1.6 选择标识符</h5><p>一旦选定了一种类型，要确保在所有关联表中都使用同样的类型。类型之间需要精确匹配，包括想unsigned这样的属性。在可以满足值得范围的需求，并且预留未来增长空间的前提下，应该选择最小的数据类型。</p>
<p><strong>整数类型</strong></p>
<p>整数通常是标识列最好的选择，因为它很快并且可以使用auto_increment。</p>
<p><strong>ENUM和SET类型</strong></p>
<p>标识列选择enum和set类型通常是一个糟糕的选择。</p>
<p><strong>字符串类型</strong></p>
<p>尽量避免使用字符串类型作为标识列，因为它消耗空间，并且通常比数字类型慢。特别是MD5(),SHA1(),UUID()产生的字符串，这些值任意分布在很大的空间内，这会导致insert和select查询变慢。因为插入值会随机的写到索引的不同位置不是顺序的写，导致insert慢。在逻辑上相邻的行会分布在磁盘或者内存不同的地方，导致查询也会变慢。另外，随机值导致缓存对所有类型的查询语句效果都很差，因为会使缓存赖以工作的访问局部性原理失效。</p>
<p>如果存储UIID，应该移除“-”；后者使用UNHEX()函数转换成16字节的数字来存储。</p>
<h5 id="4-1-7-特殊类型数据"><a href="#4-1-7-特殊类型数据" class="headerlink" title="4.1.7 特殊类型数据"></a>4.1.7 特殊类型数据</h5><p>IPv4经常看见有人使用varchar(15)来存储IP地址，然而实际上它是一个32位的无符号整数，不是字符串。MySQL提供INET_ATON()和INET_NTOA()函数在这两种表示方法之间转换。</p>
<h4 id="4-2-Schema设计中的陷阱"><a href="#4-2-Schema设计中的陷阱" class="headerlink" title="4.2 Schema设计中的陷阱"></a>4.2 Schema设计中的陷阱</h4><p><strong>太多的列</strong></p>
<p>MySQL的存储尹API在工作的时候需要在服务器层和存储引擎层之间通过行缓存格式拷贝数据，然后在服务器层将缓存内容解码成各个列。实际用到的其实是行的一小部分列，这时转换就带来了代价。</p>
<p><strong>太多个关联</strong></p>
<p>实体属性设计模式是一个常见的糟糕设计模式，MySQL限制了每个关联操作最多只能有61张表。一个经验，单个查询的关联最好控制在12张表以内。</p>
<p><strong>全能的枚举</strong></p>
<p>注意防止过度使用枚举（ENUM）类型，需要修改枚举列的值得时候在MySQL5.0以及更早的版本的时候是一个阻塞的操作。</p>
<p><strong>变相的枚举</strong></p>
<p>如果可以考虑使用枚举列替代集合列。</p>
<p><strong>非此发明的NULL</strong></p>
<p>避免使用NULL并建议尽可能的考虑替代方案，即使需要存储一个事实上的空值到表中，也不一定非得使用NULL，可以考虑使用0或者某一个特殊的值或者空字符串作为替代。</p>
<p>﻿#### 4.3 范式和反范式</p>
<h5 id="4-3-1-范式的优点和缺点"><a href="#4-3-1-范式的优点和缺点" class="headerlink" title="4.3.1 范式的优点和缺点"></a>4.3.1 范式的优点和缺点</h5><p>优点：</p>
<ul>
<li>范式化的更新操作通常比反范式要快。</li>
<li>当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据。</li>
<li>范式化的表通常更小，可以更好地存放在内存里，所以执行操作会更快。</li>
<li>很少有多余的数据意味着检索列表数据时更少需要distinct或者group by语句。</li>
</ul>
<p>缺点：</p>
<ul>
<li>通常需要关联。使得查询语句更复杂，还有可能导致索引失效。</li>
</ul>
<h5 id="4-3-2-反范式的优点和缺点"><a href="#4-3-2-反范式的优点和缺点" class="headerlink" title="4.3.2 反范式的优点和缺点"></a>4.3.2 反范式的优点和缺点</h5><p>反范式的数据都在一张表中，可以很好的避免关联。单独的表也能使用更有效的索引策略。</p>
<h5 id="4-3-3-混合使用范式和反范式"><a href="#4-3-3-混合使用范式和反范式" class="headerlink" title="4.3.3 混合使用范式和反范式"></a>4.3.3 混合使用范式和反范式</h5><p>事实上完全的范式和反范式都是实验室的东西，在实际的使用场景中经常混合使用范式与反范式设计。</p>
<h4 id="4-4-缓存表和汇总表"><a href="#4-4-缓存表和汇总表" class="headerlink" title="4.4 缓存表和汇总表"></a>4.4 缓存表和汇总表</h4><p>有时候提升性能最好的方法是在同一张表中保存衍生的冗余数据。有时候需要创建一张完全独立的汇总表或者缓存表。实时计算统计是很昂贵的操作，因为要扫描表中的大部分数据。</p>
<p>当重建汇总表和缓存表时，通常需要保证数据在操作时依然可用。这时候可用使用影子表来实现，可用通过一个原子的重命名操作切换影子表和原表。</p>
<h5 id="4-4-1-物化实体"><a href="#4-4-1-物化实体" class="headerlink" title="4.4.1 物化实体"></a>4.4.1 物化实体</h5><p>MySQL并不原生支持物化视图，使用开源工具Flexviews可以实现自己的物化视图。</p>
<h5 id="4-4-2-计数器表"><a href="#4-4-2-计数器表" class="headerlink" title="4.4.2 计数器表"></a>4.4.2 计数器表</h5><p>如果应用中存在计数器，则在更新计数器时可能碰上并发问题。为了获得更好的并发性，可以将计数器保存在多个行中，每次随机选择一个行进行更新，要获得统计结果使用聚合函数即可。</p>
<h4 id="4-5-加快AITER-TABLE的操作速度"><a href="#4-5-加快AITER-TABLE的操作速度" class="headerlink" title="4.5 加快AITER TABLE的操作速度"></a>4.5 加快AITER TABLE的操作速度</h4><p>MySQL的alter table的操作性能对大表来说有很大的性能问题。执行大部分修改表结构操作的方法是用新的机构建一张空表，从旧表中查询所有数据插入，然后删除旧表的数据。这样的操作需要花费很长的时间，特别是内存不足而表又大，还有很多索引的情况下尤甚。</p>
<p>MySQL5.1以及更新的版本包含一些类型的在线操作支持，不需要在整个操作过程中锁定表。一般来说，大部分的alter table操作将导致MySQL服务中断。针对一些场景有些操作技巧：一种是在一台不提供服务的机器上操作，然后和提供服务的主库进行切换；另外一种是影子拷贝，上文4.4有说到。可以使用Facebook团队的online schema change工具。</p>
<h5 id="4-5-1-只修改-frm文件"><a href="#4-5-1-只修改-frm文件" class="headerlink" title="4.5.1 只修改.frm文件"></a>4.5.1 只修改.frm文件</h5><h5 id="4-5-2-快速创建MyISAM索引"><a href="#4-5-2-快速创建MyISAM索引" class="headerlink" title="4.5.2 快速创建MyISAM索引"></a>4.5.2 快速创建MyISAM索引</h5><p>先禁用索引，载入数据，再重新启用索引。特别注意，但是这个方位对唯一索引无效。</p>
<h4 id="4-6-总结"><a href="#4-6-总结" class="headerlink" title="4.6 总结"></a>4.6 总结</h4><ul>
<li>尽量避免过度设计。</li>
<li>使用小而简单的合适数据类型，除非真实数据模型中有确切的需求，否者尽量避免使用NULL。</li>
<li>尽量使用相同的数据类型存储相似或相关的值，尤其是在关联条件列。</li>
<li>注意可变长字符串，其在临时表和排序时可能导致悲观的按最大长度分配内存。</li>
<li>尽量使用整型定义标识列。</li>
<li>避免使用已经废弃的特性。</li>
<li>小心使用ENUM和SET</li>
</ul>
<p>范式和反范式要混合使用，使用的时候考虑使用场景，没有银弹。</p>
<p>Alter Table操作相当的低效率，大部分都会锁表并且重建整张表。在一些特殊的场景可以使用非常规的方式来操作。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/MySQL/">MySQL</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2020/03/26/MySQL数据和Redis缓存一致性方案详解/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">MySQL数据和Redis缓存一致性方案详解</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2020/03/26/ZooKeeper-分布式应用的协调服务/">
        <span class="next-text nav-default">ZooKeeper-分布式应用的协调服务</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2020
    <span class="footer-author">yaoper.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a> and <a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
